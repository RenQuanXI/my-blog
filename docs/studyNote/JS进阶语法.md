## JS进阶语法

### 面向对象编程

* 定义：

> ​	Object Oriented Programming，简称OOP，是一种面向对象**编程开发思想**。他始终将**真实世界各种复杂的关系，抽象为一个个对象**，然有**对象之间的分工与合作**，完成对真实世界的模拟。
>
> ① 真实世界各种复杂的关系：盖房子
>
> ② 抽象为一个个对象（找对象）：找人，需要设计师、搬运工、砌墙师
>
> ③ 对象之间的分工：设计师设计图纸、搬运工搬砖，搬运材料、砌墙师砌墙
>
> ④ 对象之间的合作：搬运工搬砖给砌墙师用
>
> ⑤ 完成

* 面向对象编程步骤：（重点）
  1. 明确需求
  2. 划分对象
  3. 对象分工
  4. 对象合作
  5. 完成目标	

* 面向对象编程的好处
  * 适合大型的项目开发，提高开发效率
  * 易于维护

* 面向对象的特征
  * 封装，把过程封装到对象中
  * 继承，子承父业，减少代码冗余
  * 多态，一种事物（动物）具有多种形态（一只猫，一只狗·····）

### 对象

* 对象的创建

  * 自定义构造函数

    ```js
    function 构造函数名(参数...){
     this.key = value；
     .......
    }
    // 注意规范：构造函数名首字母要大写  帕斯卡（每个单词首字母大写）  驼峰（从第二个单词开始首字母大写）
    ```

  * 通过new关键字创建

    ```js
    var 对象名 = new 构造函数名（参数···）；
    ```

    

* 构造函数和普通函数的区别

  * 相同点
    * 都是函数
  * 不同点
    * 构造函数通过new关键字掉用
    * 普通函数直接调用

* new关键字的执行过程

  代码

  > ```js
  > function Student(name,age,gender) {
  > // 属性
  > this.name = name;
  > this.age = age;
  > this.gender = gender;
  > // 方法
  > this.sayHi = function() {
  >   // 方法内部：this 代表的是调用方法的对象
  >   console.log('我叫什么' + this.name)
  > };
  > this.writeCode = function() {
  >   console.log('我会写code');
  > }
  > }
  > // 创建对象
  > var zs = new Student('张三',10,'男');
  > // 使用对象
  > zs.writeCode();
  > 
  > ```

* 理论
  1. new关键字创建对象会先在内存空间中开辟出来一块区域
  2. 构造函数中的this关键字指向内存空间中开辟的区域
  3. this关键字将构造函数中的属性和方法搬运到内存空间中创建的对象
  4. 内存空间中已经有了属性和方法的对象会返回给外部的变量名

### 原型

* ##### 使用原型的原因

  * 问题：若不使用原型则会产生浪费内存的问题
  * 原因：方法放在构造函数中，每次new时，都会向对象中添加方法
  * 解决：把方案放到原型中就可以让同类型的对象共享

* ##### 原型是什么

  * 原型就是一个对象，原型一直都在

    <!--原型一直都在只是平时没有拿出来罢了-->

  * 获取原型

    * 构建函数.prototype

* ##### 构建函数和原型的关系

  * 理论，

    * 构建函数可以通过prototype获取到原型

    * 原型可以通过constructor获取到构造函数

  * 代码

    > ```js
    >  // 学生类→ 构造函数
    >  function Student(name,age,gender) {
    >    // 属性
    >    this.name = name;
    >    this.age = age;
    >    this.gender = gender;
    >  }
    > 
    >  // 获取原型
    >  // 每一个函数都有一个对应的原型
    >  var yx = Student.prototype;
    >  console.log(yx);
    >  // 原型是一个对象
    >  // 自带了一个成员：constructor → 构造函数
    >  console.log(yx.constructor === Student);
    > ```

  * 图解

    ![](https://renquanxi.github.io/iamgeWarehouse/img/构造函数和原型的相互获取.png)

* ##### ==原型的作用==

  节约内存，因为原型中存放的成员（属性或方法),都可以被相关的构造函数毒哦创建对象==共享==。

* ##### 实例对象和原型的关系

  **理论：**

  ​	①当实力对象调用一个方法或属性时他会先从自身去找，

  ​	②当自身对象找不到时，它会通过 ____proto____所提供的原型的地址，找到原型

  ​	③在原型中去找

  <!--如果找到了他的原型中还是找不到的话，那就再找再上一级的原型，直到找到他的祖级元素-->

  **代码**

  ```js
  // 学生类→ 构造函数
   function Student(name, age, gender) {
     // 属性
     this.name = name;
     this.age = age;
     this.gender = gender;
     // this.type = '学生'
   }
  
   // 获取原型
   // 每一个函数都有一个对应的原型
   var yx = Student.prototype;
   // 对象.key = value
   // 方法
   yx.sayHi = function () {
     // 方法内部：this 代表的是调用方法的对象
     console.log('我叫什么' + this.name)
   };
   yx.writeCode = function () {
     console.log('我会写code');
   }
   yx.type = '学生';
  
   // 创建对象
   var zs = new Student('张三', 10, '男');
   // 创建对象
   var ls = new Student('李四', 11, '男');
   // 创建对象
   var ww = new Student('王五', 17, '女');
  ```

  图解

  ![](https://renquanxi.github.io/iamgeWarehouse/img/向原型中查找属性或方法.png)

* ##### 原型链

  当对象调用一个方法时，它会先从自己==本身的对象中找==，如果找不到，==再去他的构造函数的原型中去找==，如果还是找不到就==再向上一层的原型中去找==，一层一层直到找到==Object的原型==为止，这个就叫原型链

  <!--如果在向上找时候找到了需要调用的方法了，那就不用向上找了-->

  ![](https://renquanxi.github.io/iamgeWarehouse/img/原型链.png)

案例  给数组扩展一个计算数字总和的方法

​	![](https://renquanxi.github.io/iamgeWarehouse/img/给数组添加一个计算数组中数组之和的方法.png)



### 继承

​	类与类之间的关系，子类继承父类中的成员。

* 继承的作用：减少代码，简化代码,

* 原型继承

  如何实现原型继承？

  * 先更改子类的原型prototype指向父类的实例对象 （即指向一个==new  父类（）==）
    * 子类prototype = new 父类（）;
  * 再给子类的圆型设置一个constructor执向子类 

代码

```js
 // 人类 → 父类
 function Person() {
   this.name = '名字';
   this.age = 10;
   this.gender = '男';
 }
 Person.prototype.sayHi = function () { console.log('你好'); };
 Person.prototype.eat = function () { console.log('我会吃。。。'); };
 Person.prototype.play = function () { console.log('我会玩'); };


 // 学生类 → 子类
 function Student() {
   this.stuId = 1000;
 }
 // 子类的原型prototyp指向父类的一个实例对象
 Student.prototype = new Person();
 // 添加一个constructor成员
 Student.prototype.constructor = Student;

 // 如何实现原型继承：
 // 给子类的原型prototype重新赋值为父类的一个实例对象。
 // 利用了原型链上属性或方法的查找规则。


 // 创建一个学生对象
 var stu1 = new Student();
 console.log(stu1.constructor)
```

图解

![](https://renquanxi.github.io/iamgeWarehouse/img/原型继承.png)

**优点：完美的继承了方法**

**缺点：无法继承属性**





* **借用继承**

  * call方法

    * 函数名.call(调用者，函数实参，函数实参······)；

    * 作用：

      该函数会立即执行，函数体内的this在被call时，this指向调用者

    * 代码

      ```js
       function Person(userName,age) {
         console.log(this===obj);
         this.userName = userName;
         this.age = age;
       } 
       // 需求：通过一种方式调用执行Person函数，并且函数内部this代表obj
       var obj = {};   // new Object()
       Person.call(obj,'张三',10);
      ```

  * 使用call实现借用继承

    * 如何实现

      > 在子类中，通过call调用父类，并更改父类中的this指向子类。

    * 代码

      ```js
       // 人类 → 父类
       function Person(name,age,gender) {
         this.name = name;
         this.age = age;
         this.gender = gender;
       }
       Person.prototype.sayHi = function () { console.log('你好'); };
       Person.prototype.eat = function () { console.log('我会吃。。。'); };
       Person.prototype.play = function () { console.log('我会玩'); };
      
      
       // 学生类 → 子类
       function Student(name,age,gender,stuId) {
         // this关键字代表谁,代表的是一个学生对象，当前创建的对象 stu1 ,stu2
         // var obj = this;
         //【借用继承】
         // Person.call(obj,name,age,gender);
         Person.call(this,name,age,gender);
         this.stuId = stuId;
       }
      
      
       // 创建第一个学生对象
       var stu1 = new Student('张三',10,'男',10086);
       // 创建第二个学生对象
       var stu2 = new Student('李四',11,'女',10010);
      ```

      

    * 图解

      ![](https://renquanxi.github.io/iamgeWarehouse/img/cal方法借用继承.png)

    * 缺点

      **优点：完美的继承了属性**

      **缺点：无法继承方法**

* **组合继承**

  * 实现

    > 原型继承和借用继承同时使用

  * 代码

    > ```js
    >  // 人类 → 父类
    >  function Person(name,age,gender) {
    >    this.name = name;
    >    this.age = age;
    >    this.gender = gender;
    >  }
    >  Person.prototype.sayHi = function () { console.log('你好'); };
    >  Person.prototype.eat = function () { console.log('我会吃。。。'); };
    >  Person.prototype.play = function () { console.log('我会玩'); };
    > 
    > 
    >  // 学生类 → 子类
    >  function Student(name,age,gender,stuId) {
    >    //【借用继承】
    >    Person.call(this,name,age,gender);
    >    this.stuId = stuId;
    >  }
    > 
    >  // 【原型继承】
    >  Student.prototype = new Person();
    >  Student.prototype.constructor = Student;
    > 
    > 
    >  // 创建第一个学生对象
    >  var stu1 = new Student('张三',10,'男',10086);
    >  // 创建第二个学生对象
    >  var stu2 = new Student('李四',11,'女',10010);
    > ```



### **扩展**

`实例对象无法去修改其构造函数的原型中的方法`，因为使用了  

==实例对象.原型中的方法=某值==

这个相当于你给这个实例对象中添加了一个属性并不能去修改到原型中的方法

> ```js
>  // 构造函数
>  function Student(name,age) {
>    this.name = name;
>    this.age = age;
>  }
>  // 原型
>  Student.prototype.type = '学生';
>  // 创建实例对象
>  var stu1 = new Student('张三',10);
>  var stu2 = new Student('李四',12);
>  // 实例对象stu1设置type 
>  stu1.type = '学员';
>  // 访问type
>  console.log(stu1.type); // 学员
>  console.log(stu2.type); // 学生  
> //打印学员信息
> console.log(stui)   //Student {name: "张三", age: 10, type: "学员"}
> console.log(stu2)   //Student {name: "李四", age: 12}
> 	
> ```



### 高阶函数

<!--eval（字符串格式的代码）→js代码；-->

#### **回顾**函数基础

* 函数的创建和调用

  > 函数声明：function.函数名（ 形参 ）{  函数体  }
  >
  > 函数表达式：var 函数名 = function（形参） {  函数体  }
  >
  > 调用：  函数名（实参）；

* 函数的参数

  > 形参：函数定义时候，小括号中的标识符。
  >
  > 实参：函数调用时候，小括号中的实际参数。
  >
  > 关系：实参传参给形参，形参在函数内部使用

* 函数的返回值

  > 关键字：return
  >
  > 作用：终止函数并返回值
  >
  > <!--如果函数内没有return，默认返回值为undefined-->

* 作用域

  > 全局作用域
  >
  > ​	函数之外的执行环境，
  >
  > ​	全局变量：在全局作用域中用var关键字创建的变量。可以在程序的任何地方使用
  >
  > 局部作用域
  >
  > ​	函数体内的执行环境
  >
  > ​	局部变量：在函数体内用var关键字声明的变量，仅仅是本函数体内使用
  >
  > ​	形参也可以理解为是局部变量
  >
  > 作用域链：先从本作用域中查找，如果查找不大，就向上级作用域中查找

* 预解析（变量的提升）

  > 在代码执行之前
  >
  > 会把用var声明的变量的变量名（仅仅是变量名)提升到当前执行环境（当前作用域）的顶部
  >
  > 会把函数声明的函数（整个函数体）提升到顶部

* 匿名函数

  > 匿名函数：没有名字的函数，要运算符配合使用
  >
  > 自调用或执行函数：
  >
  > ​	定义好了以后直接调用；
  >
  > ​	匿名函数和有名字的函数可以自调用
  >
  > 匿名函数的作用：
  >
  > ​	可以实现避免全局变量的污染
  >
  > ​	可以模拟块级作用域。

#### 函数进阶this指向问题

* 函数也是一种对象(函数的另一种创建方法)

  > ​	var 变量名 = new Function （‘参数1’，‘参数2‘·······’函数体中的代码‘）
  >
  > 代码
  >
  > ```js
  > // 函数是一种数据类型吗？
  >  // 是，Function
  >  
  >  // 函数声明创建函数
  >  // function fn(a,b) {
  >  //   console.log(a + b);
  >  // }
  >  // fn(10,20);
  > 
  >  // new 关键字创建函数
  >  // var fn = new Function('a','b','console.log(a + b)');
  >  // fn(10,20);
  > 
  >  // 扩展：
  >  // eval('字符串代码'); 把字符串代码解析成真正意义的js代码，并执行
  >  // 'alert(1 + 1)';
  >  eval('alert(1 + 1)')
  > ```

* **函数内部this指向问题**

  * 普通函数中this指向window

  * 定时器中this指向window

  * 构造函数中this指向当前创建的对象在内存空间中开辟的空间

  * 事件处理程序中this指向事件源

  * 方法中的this指向调用者

    

* **改变this指向**

  <!--改变this指向也就仅仅者调用时候改变了这一次而已，若要再次使用还需要再次调用，再次改变this的指向|9-->

  * call方法

    **语法**：==函数名.call（调用者，参数1，参数2····）==

    **作用**：函数被借用时，会立即执行；并且函数体内的this会指向借用者或调用者；

    <!--传入的参数是一个一个的参数，所以适合传入少量参数是使用-->

    **代码**：

    ```js
    function fn(name,age) {
        this.name = name;
        this.age = age;
    }
    //对象字面量
    var obj = {};
    fn.call(obj,'张三',19)；
    ```

  * apply方法

    **语法**：==函数名.apply（调用者，[参数1，参数2·····]==

    **作用**：函数被借用时会立即执行，并且函数体内的this会指向借用者或者调用者

    <!--与call方法的区别是传参方式不同，其余的一样-->

    <!--传入的参数是一个数组，所以适用于需要传入一个数组作为参数的时候用-->

    **代码**

    ```js
    function fn (name,age){
    	this.name = name;
        this.age = age;
    }
    
    var obj = {};
    fn.apply(obj,['张三',19])
    ```

    

  * bind方法

    **语法**：函数名.bind( 调用者，参数1，参数2····)；

    **作用**：函数被借用时，不会立即指向，而是返回一个新的函数。需要自己动手调用新的函数。

    <!--eg：在定时器中可以用这个改变this指向，-->

    **代码**：

    ```js
    function fn(name,age){
    	this.name = name;
        this.age = age;
    }
    var obj = {};
     fn.bind(obj,'李四'，11)（）；
     //bind返回的是一个函数，需要后面加个（）自调用一下，这样里面借用方法的对象才会生效 
    ```

    

#### 函数作为函数参数

* **回调函数**

  * 参数

    * 形参：函数定义时，小括号中的表示符；
    * 实参：函数调用时，小括号中的实际数据；
    * 关系：实参代表的实际数据传输给函数内部形参使用；
    * 应用场景：当外部向函数内传递数据时

  * **把一个函数B当实参，传给另一函数A的形参并且在函数A内部调用**，**这个就叫做回调函数**

    <!--一般是外部向内部传入一段程序时（用户定义的），此时选用回调函数（就是函数作为函数参数）-->

  * 代码

    > ```js
    > //定义函数A,传入形参V
    > function A(V){
    > 	V(11,12);
    > }
    > //调用函数A并讲一个函数B作为实参传入函数A；
    > A(function(a,b){alert(a+b);});//得出结果是23
    > ```

    **案例完成对模拟动画完成后对动画的升级封装**

    <!--详见js高级Day-5-5.6练习-->

#### 闭包

* **为什么要用闭包**

  * 变量：向内存中申请的一块空间，用来存放数据的】
  * 变量的生命周期：变量从创建到释放的过程 → 内存
  * 全局变量的生命周期：打开程序（网页）→创建变量→反复使用→关闭程序（关闭网页）→从内存中释放
  * 局部变量的生命周期：调用函数执行时→创建变量→反复使用→函数执行结束→从内存中释放
  * 作用域：
    * 内存可以访问外层，外层不能访问内存
    * 目的延长局部变量生命周期
    * 使用闭包。
    * GC（GarbageCollection） 垃圾回收机制
      * 回收没有用的数据
      * 有用的数据：被全局中操作的变量

* **如何检测一个程序中是否有闭包**

  如何检测：

  * 判断外层函数中是否嵌套有子函数

  * 看外层函数中是否有局部变量

  * 看子函数是否操作了外层函数的局部变量

  * 子函数是否和外部产生了关联（不局限于return返回，还是事件中）

    **==以上四个条件缺一不可==**

  **闭包经典案例**

  ```js
  【1】
  // 需求实现点击哪个按钮就会弹出哪个按钮的索引值	
  	<button>我是按钮1</button>
      <button>我是按钮2</button>
      <button>我是按钮3</button>
      <button>我是按钮4</button>
      <button>我是按钮5</button>
      <script>
          
          var btn = document.querySelectorAll('button');
          // 常规方式
          // for(var a = 0;a<btn.length;a++){
          //     btn[a].num = a ;
          //     btn[a].onclick = function(){
          //         alert('我是按钮'+this.num);
          //     }
          // }
          // 使用闭包(通过事件与外部产生关联)
          for (var a = 0; a < btn.length; a++) {
              (function (i) {
                  btn[i].onclick = function () {
                      alert(i);
                  }
              })(a);
          }
  【2】
  //简单的银行管理系统
  function bank（）{
  	//余额
      var money=100；
      //存钱
      function saveMoney(v){
  		money +=v;
      }
      //查询余额
      function queryMoney(){
  		console.log(money);
      }
      //取钱
      function drawMoney(v){
  		money -=v;
      }
      return {queryMoney:queryMoney,saveMoney:saveMoney,drawMoney:drawMoney}
  }
  var x = bank();
  x.drawMoney();
  ```

  

* **闭包的缺点**

  * 使用不当会造成内存泄露（内存浪费）
  * 解决：给外部引用（外部变量名）重新赋值null；

* **为什么使用闭包以后，外面局部变量没有被释放**

  * 因为GC回收的是没有用处的数据，而使用了闭包以后就像相当于外部作用域正在间接的操作局部作用域，所以函数内的局部变量就相当于正在使用中所以就不会被GC回收掉

* **闭包的作用**：①延长局部变量的生命周期   ②维护私有变量-局部变量的安全

  

* 在程序执行的过程中有这样的一个情况，就是说，在局部作用域中可以操作全局作用域中的变量，在全局作用域中无法操作局部作用域中的变量的，但是现在的需求呢是需要去在全局中操作这个局部变量的，这个时候常规情况下是无法实现的，这是为什么呢，这个呀是因为全局变量的生命周期是从程序打开后，由内存去创建的，然后在这个期间是可以一直反复调用使用的，一直到程序关闭，他才会被GC回收适当掉；但局部变量只有在函数开始执行时创建，当函数执行完毕以后就会被释放掉了，所以在全局中是无法操作到函数内部的局部变量的，那我想要在去哪聚中操作这个局部变量那怎么办呢？那无非就是去延长局部变量的生命周期啊，怎么去所以就引入了这个闭包的概念，什么是闭包呢，这个闭包呀他其实就可以理解为是定义在函数内部的一个函数，它的本质就是一个将函数内部和外部连接起来的桥梁， 







### 正则表达式

#### 正则表达式是什么

* 正则表达式是什么

  正则表达式是对**字符串操作**的一直逻辑工具，就是事先定义好的一些特定字符，及这些特定的字符的组合组成一个**规则字符串**，这个**规则字符串**用来表达对字符串的一种过滤逻辑。

> 正则表达式，就是定义好的**字符串规则**，然后根据规定实现对象字符串的匹配，提取，替换等。

* 正则表达式的作用
  * 可以通过正则表达式，从字符串中获取我们想要的特定部分（**提取**）
  * 强大的字符串替换能力
* 正则表达式的特点
  * 灵活性，逻辑性和功能性非常强
  * 可以迅速的用及其简单的方式达到字符串的复杂控制

#### 正则表达式的控制字符

* ==**元字符**==

  ​	元字符就是，在正在表达式具有特殊含义的字符

  | **元字符** | **说明**                         |
  | ---------- | -------------------------------- |
  | \d         | 匹配数字                         |
  | \D         | 匹配非数字                       |
  | \w         | 匹配字母或数字或下划线_          |
  | \W         | 匹配非字母、数字、下划线_        |
  | \s         | 匹配空白符（空格）               |
  | \S         | 匹配非空白符                     |
  | .          | 匹配任意除了换行符之外的单个字符 |

* **==限定符==**

  ​	限定符是控制字符出现的个数的

  | 限定符 | **说明**                                      |
  | ------ | --------------------------------------------- |
  | n*     | 匹配任何包含零个或多个 n 的字符串。n{0,}      |
  | n+     | 匹配任何包含至少一个 n 的字符串。{1,}         |
  | n?     | 匹配任何包含零个或一个 n 的字符串。{0,1}      |
  | n{x}   | 匹配包含 x 个 n 的序列的字符串                |
  | n{x,}  | 匹配包含至少 x 个 n 的序列的字符串。          |
  | n{x,y} | 匹配包含 至少x个 至多 y 个 n 的序列的字符串。 |
  | n$     | 匹配任何结尾为 n 的字符串                     |
  | ^n     | 匹配任何开头为 n 的字符串                     |

  **注意1：**  在使用花括号限制字符个数是，将来在去匹配时，首先从前向后匹配，，按照至多的需求匹配，至多不满足时，再降低要求匹配，若降至最小时还不匹配，→  最终结果  不匹配

  **注意2**：  关于次数至少是0时，表示有没有都符合，没有符合的，或者内容不是的，没有该类内容的，都都算是符合

* **==中括号==**

  中括号就代表一个字符，中括号的目的就是控制一个字符的范围，

  | 中括号          | 说明                                                      |
  | --------------- | --------------------------------------------------------- |
  | [abc]           | 查找一个方括号之间的任何字符。                            |
  | [ ^abc]         | 查找一个任何不在方括号之间的字符。^在中括号中有取反的意思 |
  | [0-9]           | 查找一个任何从 0 至 9 的数字。                            |
  | [a-z]           | 查找一个任何从小写 a 到小写 z 的字符。                    |
  | [A-Z]           | 查找一个任何从大写 A 到大写 Z 的字符。                    |
  | [A-z]           | 查找一个字母（包含大小写和下划线）                        |
  | [\u4e00-\u9fa5] | 查找一个汉字                                              |

  ​		在匹配时，从前向后按照【规则】去找，若是全局匹配，前面若有满足项时，后面再匹配时，从满足项的下一开始去匹配

  ```js
  //例:现在要去匹配^\d{4}[0-9]$   匹配0-9之间的4位数字
  123456789056582895247
  //匹配上面的数字
  //当匹配到1234是合格的以后，再去匹配就会从5678开始匹配了
  ```

==^正则表达式$==：**会对字符串进行整体校验，完全符合条件所指才能够匹配。**

**（注：：：在使用提取功能时不能加这个， 其他情况判定时都会使用)**

#### 正则表达式的模式和情况

* **或模式**

  *  特殊符号：**正则1|正则2**，           <!--符合或两边的其中一个就可以匹配-->。
    * eggoole，baidu，bing；//匹配三种其中一种字符串
    * 正则 google|baidu|bing

* **分组模式**

  * 特殊符号**（正则）**；
    * 组指的是一个小集体，分组就是将一个大集体分成几个小集体。
    * 如：控制你的名字连续出现的次数，最少一次最多三次
    * ^(你的名字){1，3}$

* **修饰符**

  * **g**

    * g，全称global  有全局的意思，表示全局匹配
    * 如：var   reg  =  /hellow/g

  * **i**

    * i，全称ignore，有忽视，忽略的意思，表示匹配字母时，可以忽略字母的大小。
    * eg：var reg = /Hellow/i;

  * **gi**   ig

    * gi,   全局匹配和忽略大小写一起使用。
    * var reg = /hellow/gi;

    

* **正则转义符**

  ​	==**.**==在正则中标识特殊符号，去除**==.==**的特殊意义，需要转义符：` \.`

* **练习**

  * 验证邮箱   

    > `^\w+@\w+\.\w+$`
    >
    > `^\w+@\w+\.[a-z]{2,3}$`
    >
    > `^\d{5,11}@qq\.com$`
    >
    > `^\w+@[0-9a-z]{2,12}\.(com|cn)$`

  * 验证身份证号

    > `^\d{17}[\dX]$`
    >
    > `^\d{17}(\d|X)$`

  * 验证手机号

    > `^\d{11}$`

  * 验证日期  2018-12-10

    > `^\d{4}-\d{1,2}-\d{1,2}$`

  * 验证IP  XXX.XXX.XXX.XXX

    > `^\d{1,3}\(.\d{1,3}){3}$`
    >
    > `\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}`



#### 正则表达式在js中的使用

* 正则表达式对象

  * 创建正则表达式对象	

    * 方式①

      * **var  变量  =  new  RegExp （“规则”，“修饰符”）**
      * 代码

      ```js
      var  reg = new RegExp('\\d','g');
      ```

    * 方式② 字面量或者直接量

      * **var  变量 =  /正则表达式/**
      * 代码：

      ```js
      var reg = /\d/g;
      ```

  * **检测匹配**

    * ==正则对象.test(字符串)==；用于检测字符串是否匹配某个规则，返回布尔值

* **字符串对象方法相关正则使用**

  * 字符串.match(正则对象)，提取所有匹配的内容
    * ==获取==匹配正则的字符串，返回一个==数组==。
  * 字符串.replace（正则对象，替换后的内容）；
    * ==替换==所有匹配正则的子字符串。返回替换后的==字符串==

### 递归

* **递归是什么**
  * 递归：函数自身的编程技巧	






























































